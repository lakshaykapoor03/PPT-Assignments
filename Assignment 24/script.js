//Answer 1

function romanToInteger(romanNumeral) {
    // Initialize the roman numeral value.
    let romanNumeralValue = 0;
  
    // Create a lookup table for the roman numerals.
    const romanNumeralLookup = {
      "I": 1,
      "V": 5,
      "X": 10,
      "L": 50,
      "C": 100,
      "D": 500,
      "M": 1000,
    };
  
    // Iterate over the roman numeral string.
    for (let i = 0; i < romanNumeral.length; i++) {
      // Get the current roman numeral symbol.
      const currentRomanNumeralSymbol = romanNumeral[i];
  
      // Get the value of the current roman numeral symbol.
      const currentRomanNumeralValue = romanNumeralLookup[currentRomanNumeralSymbol];
  
      // If the next roman numeral symbol has a larger value, subtract the current roman numeral value.
      if (i + 1 < romanNumeral.length && romanNumeralLookup[romanNumeral[i + 1]] > currentRomanNumeralValue) {
        romanNumeralValue -= currentRomanNumeralValue;
      } else {
        // Otherwise, add the current roman numeral value.
        romanNumeralValue += currentRomanNumeralValue;
      }
    }
  
    // Return the roman numeral value.
    return romanNumeralValue;
  }
  
  const romanNumeral = "MCMXLVII";
const romanNumeralValue = romanToInteger(romanNumeral);
console.log(romanNumeralValue); // 1947


//Answer 2
function longestSubstringWithoutRepeatingCharacters(s) {
    // Initialize the longest substring length.
    let longestSubstringLength = 0;
  
    // Initialize the set of characters seen so far.
    const seenCharacters = new Set();
  
    // Iterate over the string.
    for (let i = 0; i < s.length; i++) {
      // If the current character is not seen yet, add it to the set of seen characters.
      if (!seenCharacters.has(s[i])) {
        seenCharacters.add(s[i]);
      } else {
        // Otherwise, the current substring is no longer the longest substring.
        longestSubstringLength = Math.max(longestSubstringLength, seenCharacters.size);
  
        // Remove all characters from the set that are less than the current character.
        while (seenCharacters.has(s[i - longestSubstringLength])) {
          seenCharacters.delete(s[i - longestSubstringLength]);
        }
      }
    }
  
    // Return the longest substring length.
    return Math.max(longestSubstringLength, seenCharacters.size);
  }
  
  const s = "abcabcbb";
const longestSubstringLength = longestSubstringWithoutRepeatingCharacters(s);
console.log(longestSubstringLength); // 3




//Answer 3


function majorityElement(nums) {
    // Initialize the majority element and its count.
    let majorityElement = nums[0];
    let majorityElementCount = 1;
  
    // Iterate over the array.
    for (let i = 1; i < nums.length; i++) {
      // If the current element is the majority element, increment its count.
      if (nums[i] === majorityElement) {
        majorityElementCount++;
      } else {
        // Otherwise, decrement the count of the majority element.
        majorityElementCount--;
  
        // If the count of the majority element is 0, set the majority element to the current element and reset its count to 1.
        if (majorityElementCount === 0) {
          majorityElement = nums[i];
          majorityElementCount = 1;
        }
      }
    }
  
    // Return the majority element.
    return majorityElement;
  }
  
  const nums = [1, 2, 3, 3, 3, 2, 2, 2, 1];
const majorityElement = majorityElement(nums);
console.log(majorityElement); // 2



//Answer 4
function groupAnagrams(strs) {
    // Initialize the map of anagrams.
    const anagrams = new Map();
  
    // Iterate over the strings.
    for (const str of strs) {
      // Calculate the hash of the string.
      const hash = str.split("").sort().join("");
  
      // If the hash is not in the map, add it to the map.
      if (!anagrams.has(hash)) {
        anagrams.set(hash, []);
      }
  
      // Add the string to the list of anagrams in the map.
      anagrams.get(hash).push(str);
    }
  
    // Return the list of anagrams.
    return Object.values(anagrams);
  }
  
  const strs = ["eat", "tea", "tan", "ate", "nat", "bat"];
const anagrams = groupAnagrams(strs);
console.log(anagrams); // [["bat"],["nat","tan"],["ate","eat","tea"]]


// Answer 5
function nthUglyNumber(n) {
    // Initialize the list of ugly numbers.
    const uglyNumbers = [1];
  
    // Initialize the pointers to the next ugly numbers generated by multiplying by 2, 3, and 5.
    let twoPointer = 0;
    let threePointer = 0;
    let fivePointer = 0;
  
    // Iterate until we have n ugly numbers.
    for (let i = 1; i < n; i++) {
      // Get the smallest of the three ugly numbers.
      const nextUglyNumber = Math.min(uglyNumbers[twoPointer] * 2, uglyNumbers[threePointer] * 3, uglyNumbers[fivePointer] * 5);
  
      // Add the smallest ugly number to the list.
      uglyNumbers.push(nextUglyNumber);
  
      // Update the pointers to the next ugly numbers generated by multiplying by 2, 3, and 5.
      if (nextUglyNumber === uglyNumbers[twoPointer] * 2) {
        twoPointer++;
      } else if (nextUglyNumber === uglyNumbers[threePointer] * 3) {
        threePointer++;
      } else {
        fivePointer++;
      }
    }
  
    // Return the nth ugly number.
    return uglyNumbers[n - 1];
  }
  
  const n = 10;
const nthUglyNumber = nthUglyNumber(n);
console.log(nthUglyNumber); // 12


//Answer 6

function topKFrequentWords(words, k) {
    // Initialize the map of words and their frequencies.
    const wordFrequencies = new Map();
  
    // Iterate over the words.
    for (const word of words) {
      // If the word is not in the map, add it to the map with a frequency of 1.
      if (!wordFrequencies.has(word)) {
        wordFrequencies.set(word, 1);
      } else {
        // Otherwise, increment the frequency of the word.
        wordFrequencies.set(word, wordFrequencies.get(word) + 1);
      }
    }
  
    // Initialize the priority queue of words.
    const priorityQueue = new PriorityQueue((a, b) => {
      // Sort the words by their frequency in descending order.
      if (a[1] !== b[1]) {
        return b[1] - a[1];
      } else {
        // Sort the words with the same frequency by their lexicographical order.
        return a[0].localeCompare(b[0]);
      }
    });
  
    // Add the words to the priority queue.
    for (const [word, frequency] of wordFrequencies.entries()) {
      priorityQueue.enqueue([word, frequency]);
    }
  
    // Initialize the list of top k frequent words.
    const topKFrequentWords = [];
  
    // Iterate over the priority queue and add the top k frequent words to the list.
    for (let i = 0; i < k; i++) {
      const [word, frequency] = priorityQueue.dequeue();
      topKFrequentWords.push(word);
    }
  
    // Return the list of top k frequent words.
    return topKFrequentWords;
  }
  
  const words = ["i", "love", "leetcode", "i", "love", "coding"];
const k = 2;
const topKFrequentWords = topKFrequentWords(words, k);
console.log(topKFrequentWords); // ["i", "love"]


//Answer 7

function slidingWindowMaximum(nums, k) {
    // Initialize the list of max sliding windows.
    const maxSlidingWindows = [];
  
    // Initialize the queue of max values in the sliding window.
    const queue = [];
  
    // Iterate over the array.
    for (let i = 0; i < nums.length; i++) {
      // If the queue is full, remove the smallest element from the queue.
      if (queue.length === k) {
        queue.shift();
      }
  
      // Add the current element to the queue.
      queue.push(nums[i]);
  
      // If the current element is greater than the max element in the queue, update the max element in the queue.
      if (nums[i] > queue[0]) {
        queue[0] = nums[i];
      }
  
      // Add the max element in the queue to the list of max sliding windows.
      if (i >= k - 1) {
        maxSlidingWindows.push(queue[0]);
      }
    }
  
    // Return the list of max sliding windows.
    return maxSlidingWindows;
  }
  

  const nums = [1, 3, -1, -3, 5, 3, 6, 7];
const k = 3;
const maxSlidingWindows = slidingWindowMaximum(nums, k);
console.log(maxSlidingWindows); // [3, 3, 5, 5, 6, 7]



//Answer 8

function kClosestToX(arr, k, x) {
    // Initialize the list of closest integers to x.
    const closestIntegers = [];
  
    // Iterate over the array.
    for (let i = 0; i < arr.length; i++) {
      // Calculate the distance between the current element and x.
      const distance = Math.abs(arr[i] - x);
  
      // If the current element is closer to x than the last element in the list of closest integers, add it to the list.
      if (closestIntegers.length === 0 || distance < closestIntegers[closestIntegers.length - 1]) {
        closestIntegers.push(arr[i]);
  
        // If the list of closest integers is already full, remove the farthest element from the list.
        if (closestIntegers.length === k) {
          closestIntegers.shift();
        }
      }
    }
  
    // Return the list of closest integers to x.
    return closestIntegers;
  }

  
  const arr = [1, 2, 3, 4, 5];
const k = 4;
const x = 3;
const closestIntegers = kClosestToX(arr, k, x);
console.log(closestIntegers); // [1,2,3,4]







